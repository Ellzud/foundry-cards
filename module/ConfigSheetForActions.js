import { DeckParameters, StackConfiguration } from "./constants.js";
import { CARD_STACKS_DEFINITION } from "./StackDefinition.js";
import { updateCardStackSettings } from "./tools.js";


/**
 * During configBox creation for each stack.
 * Map stack config value and labels for a given conf key
 * @param {object} stack a stack from this.object.stacks
 * @param {string} configName The conf key
 * @returns {object} will be stored as a configBoxes element
 */
const mapConfBoxForStack = (stack, configName) => {

	const toggled = stack.config[configName];
	let classes = toggled ? 'far fa-check-square' : 'far fa-square';

	const key = DeckParameters.overrideConf;
	if( !stack.parameters.hasOwnProperty(key) || stack.parameters[key] ) {
		classes += ' active';
	}

	return {
		config: configName,
		classes: classes,
		label: stack.gui.labels[configName]
	};
};

/**
 * During configBox creation for the filter.
 * @param {object} configUsage The conf key
 * @returns {object} will be stored as a configBoxes element
 */
 const mapConfBoxForFilter = (confUsage) => {

	let classes = confUsage.toggled ? 'far fa-check-square' : 'far fa-square';
	classes += ' active';

	return {
		config: confUsage.config,
		classes: classes,
		label: game.i18n.localize('RTUCards.settings.sheet.labels.' + confUsage.config)
	};
};

const buildStackActions = (stack) => {
	const actions = [];

	// Deck desc
	const desc = stack.gui.deck.desc;
	if( desc && desc != '' ) {
		actions.push(
			createActionLine({ icon: 'fas fa-info', clickable: false, labelKey: stack.gui.deck.desc })
		);
	}

	// Deck edition
	[DeckParameters.labelBaseKey, DeckParameters.resourceBaseDir].forEach( key => {
		if( stack.parameters.hasOwnProperty(key) ) {
			actions.push(
				createActionLine({ 
					icon: 'far fa-edit', clickable: false, param: key, 
					labelKey: 'RTUCards.settings.config-actions.additionalData.' + key,
					editText: stack.parameters[key]
				})
			);
		}
	})


	// Some stacks may have some custom card implem. Warn the user that the action listing may not be used
	if( stack.useCustomCardImpl ) {
		actions.push(
			createActionLine({ icon: 'fas fa-exclamation', clickable: false, labelKey: 'RTUCards.settings.config-actions.additionalData.warnImplem' })
		);
	}

	// For stack generated by code : See if the user can override conf values
	const overrideKey = DeckParameters.overrideConf;
	if( stack.parameters.hasOwnProperty(overrideKey) ) {
		const icon = stack.parameters[overrideKey] ? 'fas fa-lock-open' : 'fas fa-lock';
		actions.push(
			createActionLine({ icon: icon, param: overrideKey, labelKey: 'RTUCards.settings.config-actions.additionalData.overrideConf' })
		);
	}

	// Only add the header is there are some actions
	const result = [];
	if( actions.length > 0 ) {
		result.push({isHeader:true, label: game.i18n.localize('RTUCards.settings.config-actions.additionalData.headerDeck') });
		result.push(...actions);
	}

	return result;
}

const createActionLine = ({icon='', clickable=true, labelKey='', param='', editText=null} = {}) => {
	const result = {};
	result.classes = icon;
	if( clickable ) { result.classes += ' active'; }

	result.label = game.i18n.localize(labelKey);
	result.param = param;

	result.input = {
		displayed: (editText != null),
		text: editText
	};

	return result;
}

/**
 * A configuration sheet to configure available actions for each declared deck
 * @extends {FormApplication}
 */
export class ConfigSheetForActions extends FormApplication {


	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "rtucards-config-actions",
			classes: ["rtucards-config-actions"],
			template: "modules/ready-to-use-cards/resources/config-actions.hbs",
			width: 600,
			height: "auto",
			closeOnSubmit: false,
            scrollY: [".deck-list"]
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		return game.i18n.localize("RTUCards.settings.config-actions.menu");
	}

	/* -------------------------------------------- */

	constructor(object={}, options={}) {
		super(object, options);
		this.module = game.modules.get('ready-to-use-cards');
		this.initStacks();
		this.initFilter();
	}

	initStacks( ) {

		// Prepare configBoxes
		const configLabels = {};
		this.configBoxes = Object.values(StackConfiguration);
		this.configBoxes.forEach( key => {
			configLabels[key] = game.i18n.localize('RTUCards.settings.sheet.labels.' + key);
		});

		// List of the available configuration settings.
		const defaultStackConfig = this.configBoxes.reduce( (_config, confKey) => {
			_config[confKey] = true;
			return _config;
		}, {});

		const cardStacks = this.module.cardStacks;
		const actualDefinition = CARD_STACKS_DEFINITION;

		// First : List all possible card stacks from classic declaration (default and manuallyRegistered)
		//--------------------
		this.object.stacks = Object.entries(cardStacks.defaultCoreStacks).map( ([key, stackDef]) => {

			const declared = actualDefinition.core.hasOwnProperty(key);

			const data = {};
			data.key = key;
			data.isDefaultStack = true;
			data.useCustomCardImpl = false;

			// config : Used to define which actions are available once a card stack is opened
			const config = duplicate(defaultStackConfig);
			if( declared ) { // Substitute current config values
				Object.entries( actualDefinition.core[key].config ).forEach( ([key, confValue]) => {
					config[key] = confValue;
				});
			}
			data.config = config;

			// parameters : Additional info on deck, like image path or translation prefix
			const parameters = {};
			parameters.labelBaseKey = declared ? actualDefinition.core[key].labelBaseKey : stackDef.labelBaseKey;
			parameters.resourceBaseDir = declared ? actualDefinition.core[key].resourceBaseDir : stackDef.resourceBaseDir;
			data.parameters = parameters;

			const registeredSuffix = game.i18n.localize('RTUCards.coreStacks.suffix.manuallyRegistered');;
			const deckName = stackDef.customName ?? game.i18n.localize(stackDef.labelBaseKey + 'title');
			const deckDesc = stackDef.customDesc ?? game.i18n.localize(stackDef.labelBaseKey + 'description');

			data.gui = {
				toggled: cardStacks.decks.hasOwnProperty( key ),
				toggleLocked: stackDef.isManuallyRegistered ?? false,
				detailsDisplayed: false,
				deck: {
					name: deckName + (stackDef.isManuallyRegistered ? registeredSuffix : '' ),
					desc: deckDesc
				},
				labels: configLabels
			};
			return data;
		});

		// Then : Add card stacks declared inside hooks
		//--------------------
		const viaCodeSuffix = game.i18n.localize('RTUCards.coreStacks.suffix.viaCode');;
		const customDefs = Object.entries(actualDefinition.core).filter( ([coreKey, coreDef]) => !this.object.stacks.find(s => s.key === coreKey) );
		customDefs.forEach( ([coreKey, coreDef]) => {

			const data = {};
			data.key = coreKey;
			data.isDefaultStack = false;
			data.useCustomCardImpl = coreDef.cardClass != actualDefinition.shared.cardClasses.simple;

			// config : Used to define which actions are available once a card stack is opened
			const config = duplicate(defaultStackConfig);
			Object.entries( coreDef.config ).forEach( ([key, confValue]) => {
				config[key] = confValue;
			});
			data.config = config;

			// parameters : Additional info on deck, like image path or translation prefix
			const parameters = {};
			parameters.labelBaseKey = coreDef.labelBaseKey;
			parameters.resourceBaseDir = coreDef.resourceBaseDir;
			parameters.overrideConf = coreDef.overrideConf;
			data.parameters = parameters;
			
			data.gui = {
				toggled: true,
				toggleLocked: true,
				detailsDisplayed: false,
				deck: {
					name: game.i18n.localize(coreDef.labelBaseKey + 'title') + viaCodeSuffix,
					desc: game.i18n.localize(coreDef.labelBaseKey + 'description')
				},
				labels: configLabels
			};
			this.object.stacks.push(data);
		});
	}
	
	initFilter() {
		this.filter = {
			detailsDisplayed: false,
			title: game.i18n.localize('RTUCards.settings.config-actions.filter.title'),
			configUsage: []
		};
		this.reloadFilter();
	}

	reloadFilter() {
		const usedStacks = this.object.stacks.filter( stack => stack.gui.toggled );
		this.filter.configUsage = this.configBoxes.map( key => {
			const used = usedStacks.some( stack => {
				return stack.config[key];
			});

			return {
				config: key,
				toggled: used
			};
		});
	}

	_addHeadersToConfigBoxes(configBoxes) {

		const result = [];
		['fromDeck', 'fromHand', 'fromRevealed', 'fromDiscard'].forEach( header => {

			const relatedConfs = configBoxes.filter( cb => cb.config.startsWith(header) );
			if( relatedConfs.length > 0 ) {

				result.push({ // Header line
					isHeader: true, 
					label: game.i18n.localize('RTUCards.settings.sheet.headers.' + header) 
				});

				relatedConfs.sort( (a,b) => a.label.localeCompare(b.label) );
				result.push(...relatedConfs);
			}
		});
		return result;
	}

	_prepareStackList() {

		// Add confboxes information for each stack
		const stacks = this.object.stacks.map( stack => {
			const data = {
				configBoxes: this.configBoxes.map( confKey => mapConfBoxForStack( stack, confKey ) ),
				actions: buildStackActions(stack)
			};

			return foundry.utils.mergeObject( data, stack );
		});
		return stacks;
	}

	_prepareFilteringWithStacks(stacks) {

		// Retrieve confs which are never used
		const unusedKeys = this.filter.configUsage.filter( c => !c.toggled).map( c => c.config );

		// Reduce confboxes on each stack by removing those elements
		stacks.forEach( stack => {
			stack.configBoxes = stack.configBoxes.filter( cb => cb.isHeader || !unusedKeys.includes(cb.config) );
		});

		const result = { 
			configBoxes: this.filter.configUsage.map( cu => mapConfBoxForFilter(cu) ) ,
			actions: [
				{isHeader:true, label: game.i18n.localize('RTUCards.settings.config-actions.additionalData.headerFilter')},
				createActionLine({ icon: 'fas fa-info', clickable: false, labelKey: 'RTUCards.settings.config-actions.filter.details' })
			]
		};
		return foundry.utils.mergeObject(result, this.filter);
	}

	/** @override */
	async getData() {

		const stacks = this._prepareStackList();
		const filter = this._prepareFilteringWithStacks(stacks);

		// Add headers at the end (wait until entries have been filtered)
		stacks.forEach(stack => {
			stack.configBoxes = this._addHeadersToConfigBoxes(stack.configBoxes);
		});
		filter.configBoxes = this._addHeadersToConfigBoxes(filter.configBoxes);

		return {
			stacks: stacks,
			filter: filter
		};
	}

	/** @override */
    activateListeners(html) {
		html.find('.filter .toggle-button.show').click(event => this._onClickToggleFilter(event) );
		html.find('.filter .toggle-button.config').click(event => this._onClickToggleFilterBox(event) );

		html.find('.declared-deck .toggle-button.deck.active').click(event => this._onClickToggleDeck(event) );
		html.find('.declared-deck .toggle-button.show.active').click(event => this._onClickToggleDetails(event) );
		html.find('.declared-deck .toggle-button.config.active').click(event => this._onClickToggleConfigBox(event) );
		
		html.find('.declared-deck .toggle-button.action.active').click(event => this._onClickToggleParameter(event) );
        html.find('.declared-deck .param-input').change(event => this._onChangeParameterValue(event) );


		html.find('.save-stacks').click(event => this._onClickSaveConfig(event) );
	}

	/** @override */
	_updateObject(event, formData) {
		// Not used
	}

	/* -------------------------------------------- */

	async _onClickSaveConfig(event) {
		const decks = {};
		this.object.stacks.filter( s => s.gui.toggled ).forEach( stack => {
			decks[stack.key] = duplicate(stack.config);
			decks[stack.key].parameters = stack.parameters;
		});

        await updateCardStackSettings(decks);
		await this.module.cardStacks.loadCardStacks();
		this.close();
	}

	async _onClickToggleFilter(event) {
		event.preventDefault();
		this.filter.detailsDisplayed = !this.filter.detailsDisplayed;
		this.render();
	}

	async _onClickToggleDeck(event) {
		event.preventDefault();
		const a = event.currentTarget;
		const key = a.parentElement.parentElement.dataset.key;

		const stack = this.object.stacks.find( s =>s.key === key );
		const wasToggled = stack.gui.toggled;
		stack.gui.toggled = !wasToggled;
		stack.gui.detailsDisplayed = !wasToggled;
		this.render();
	}

	async _onClickToggleDetails(event) {
		event.preventDefault();
		const a = event.currentTarget;
		const key = a.parentElement.parentElement.dataset.key;

		const stack = this.object.stacks.find( s =>s.key === key );
		stack.gui.detailsDisplayed = !stack.gui.detailsDisplayed;
		this.render();
	}

	async _onClickToggleConfigBox(event) {
		event.preventDefault();
		const a = event.currentTarget;
		const deckKey = a.parentElement.parentElement.dataset.key;
		const configKey = a.dataset.config;

		const stack = this.object.stacks.find( s =>s.key === deckKey );
		stack.config[configKey] = !stack.config[configKey];
		this.render();
	}

	async _onClickToggleParameter(event) {
		event.preventDefault();
		const a = event.currentTarget;
		const deckKey = a.parentElement.parentElement.dataset.key;
		const paramKey = a.parentElement.dataset.param;

		const stack = this.object.stacks.find( s =>s.key === deckKey );
		stack.parameters[paramKey] = !stack.parameters[paramKey];
		this.render();
	}

	async _onChangeParameterValue(event) {
		event.preventDefault();
		const a = event.currentTarget;
		const deckKey = a.parentElement.parentElement.dataset.key;
		const paramKey = a.parentElement.dataset.param;

		const stack = this.object.stacks.find( s =>s.key === deckKey );
		stack.parameters[paramKey] = a.value;
		this.render();
	}

	async _onClickToggleFilterBox(event) {
		const a = event.currentTarget;
		const configKey = a.dataset.config;

		const relatedConfig = this.filter.configUsage.find( c => c.config === configKey );
		const wasChecked = relatedConfig.toggled;
		relatedConfig.toggled = !wasChecked;

		if( wasChecked ) { // Uncheck box on all stacks
			this.object.stacks.forEach( stack => {
				stack.config[configKey] = false;
			});
		}
		this.render();
	}
}

